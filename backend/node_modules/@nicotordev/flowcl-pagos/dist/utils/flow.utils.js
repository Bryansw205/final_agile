"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPaymentMethod = getPaymentMethod;
exports.getPaymentStatus = getPaymentStatus;
exports.isValidPaymentReceivedByDate = isValidPaymentReceivedByDate;
exports.generateSignature = generateSignature;
exports.generateFormData = generateFormData;
const flow_constants_1 = __importDefault(require("../constants/flow.constants"));
const date_fns_1 = require("date-fns");
const crypto_js_1 = __importDefault(require("crypto-js"));
/**
 * Obtiene el código de metodo de pago en Flow.
 * @param paymentMethod El metodo de pago "webpay-plus" | "mach" | "khipu" | "redpay" | "onepay" | "flow"
 * @returns El codigo de metodo de pago en Flow.
 */
function getPaymentMethod(paymentMethod) {
    return flow_constants_1.default.FLOW_PAYMENT_METHOD_CODES[paymentMethod];
}
/**
 * Obtiene el estado de un pago en Flow.
 * @param status numero de estado
 * @returns El estado del pago en Flow en formato string.
 */
function getPaymentStatus(status) {
    return flow_constants_1.default.FLOW_PAYMENT_STATUS_CODES[status];
}
/**
 * Verifica si una fecha está en el formato YYYY-MM-DD o intenta convertirla.
 * @param dateString La fecha en formato string o Date.
 * @returns La fecha en formato YYYY-MM-DD si es válida, o null si no puede convertirse.
 */
function isValidPaymentReceivedByDate(dateString) {
    if (typeof dateString === 'string' &&
        /^\d{4}-\d{2}-\d{2}$/.test(dateString)) {
        return dateString;
    }
    const parsedDate = (0, date_fns_1.parse)(dateString.toString(), 'yyyy-MM-dd', new Date());
    if ((0, date_fns_1.isValid)(parsedDate)) {
        return (0, date_fns_1.format)(parsedDate, 'yyyy-MM-dd');
    }
    return null;
}
/**
 * Genera una firma HMAC-SHA256 para asegurar la autenticidad de los datos enviados a Flow.
 * @param params Parámetros a firmar.
 * @returns Firma generada.
 */
function generateSignature(params, secretKey) {
    const sortedKeys = Object.keys(params).sort(); // Ordenar las claves alfabéticamente
    let toSign = '';
    sortedKeys.forEach((key) => {
        toSign += key + params[key]; // Concatenar clave y valor
    });
    return crypto_js_1.default.HmacSHA256(toSign, secretKey).toString(); // Generar firma
}
/**
 * Genera un objeto con los datos a enviar y la firma HMAC-SHA256.
 * @param data Recibe un objeto con los datos a enviar
 * @param secretKey Recibe la clave secreta para firmar los datos
 * @returns Retorna un objeto con los datos y la firma
 */
function generateFormData(data, secretKey) {
    const signature = generateSignature(data, secretKey); // Generar firma
    return {
        ...data,
        s: signature, // Agregar firma a los datos enviados
    };
}
//# sourceMappingURL=flow.utils.js.map